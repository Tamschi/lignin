<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="API documentation for the Rust `auto_safety` mod in crate `lignin`."><meta name="keywords" content="rust, rustlang, rust-lang, auto_safety"><title>lignin::auto_safety - Rust</title><link rel="stylesheet" type="text/css" href="../../normalize.css"><link rel="stylesheet" type="text/css" href="../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../../light.css"  id="themeStyle"><link rel="stylesheet" type="text/css" href="../../dark.css" disabled ><link rel="stylesheet" type="text/css" href="../../ayu.css" disabled ><script id="default-settings"></script><script src="../../storage.js"></script><noscript><link rel="stylesheet" href="../../noscript.css"></noscript><link rel="icon" type="image/svg+xml" href="../../favicon.svg">
<link rel="alternate icon" type="image/png" href="../../favicon-16x16.png">
<link rel="alternate icon" type="image/png" href="../../favicon-32x32.png"><style type="text/css">#crate-search{background-image:url("../../down-arrow.svg");}</style></head><body class="rustdoc mod"><!--[if lte IE 8]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu">&#9776;</div><a href='../../lignin/index.html'><div class='logo-container rust-logo'><img src='../../rust-logo.png' alt='logo'></div></a><p class="location">Module auto_safety</p><div class="sidebar-elems"><div class="block items"><ul><li><a href="#macros">Macros</a></li><li><a href="#traits">Traits</a></li></ul></div><p class="location"><a href="../index.html">lignin</a></p><script>window.sidebarCurrent = {name: "auto_safety", ty: "mod", relpath: "../"};</script><script defer src="../sidebar-items.js"></script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!" aria-haspopup="menu"><img src="../../brush.svg" width="18" alt="Pick another theme!"></button><div id="theme-choices" role="menu"></div></div><script src="../../theme.js"></script><nav class="sub"><form class="search-form"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" disabled autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><button type="button" class="help-button">?</button>
                <a id="settings-menu" href="../../settings.html"><img src="../../wheel.svg" width="18" alt="Change settings"></a></div></form></nav><section id="main" class="content"><h1 class="fqn"><span class="out-of-band"><span id="render-detail"><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span><a class="srclink" href="../../src/lignin/auto_safety.rs.html#1-819" title="goto source code">[src]</a></span><span class="in-band">Module <a href="../index.html">lignin</a>::<wbr><a class="mod" href="">auto_safety</a></span></h1><div class="docblock"><p>Transitive (across function boundaries) <a href="../../lignin/trait.ThreadSafety.html" title="ThreadSafety"><code>ThreadSafety</code></a> inference, mainly for use by frameworks.</p>
<p>All methods in this module are always-inlined no-ops, meaning that there is zero runtime cost to them.</p>
<blockquote>
<p>This feature relies on opaque return types (<code>-&gt; impl Trait</code>) leaking <a href="https://doc.rust-lang.org/nightly/core/marker/trait.Send.html" title="Send"><code>Send</code></a> and <a href="https://doc.rust-lang.org/nightly/core/marker/trait.Sync.html" title="Sync"><code>Sync</code></a>, so the theoretical limit here, even after specialization lands, are four distinct 'real' types with restrictions on conversion incompatibilities.
Fortunately, <code>lignin</code> only needs two of these slots with straightforward compatibility, the <code>!Send + !Sync</code> and the <code>Send + Sync</code> one.</p>
<p>Please refer to the item documentation for implementation details.</p>
</blockquote>
<p><strong>The following is a long explanation that you probably don't have to read.</strong><br />
In hand-written code, you can always use <a href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="From"><code>From</code></a> or <a href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="Into"><code>Into</code></a> to cast a <a href="../../lignin/struct.ThreadSafe.html"><code>…&lt;ThreadSafe&gt;</code></a> type to the matching <a href="../../lignin/struct.ThreadBound.html"><code>…&lt;ThreadBound&gt;</code></a> type where necessary.<br />
If you receive an opaque type, <code>use lignin::auto_safety::{AutoSafe as _, Deanonymize as _};</code> and call <code>.deanonymize()</code> on it, then <strong>politely</strong> ask the author to consider being more specific.</p>
<p>If you do intend to use this module, please still declare <a href="../../lignin/struct.ThreadSafe.html" title="ThreadSafe"><code>ThreadSafe</code></a> explicitly at crate boundaries, or encourage developers using your library to do so.
<a href="#limiting-autosafe-exposure">You can find more information on this near the end of this page.</a></p>
<h1 id="examples--usage" class="section-header"><a href="#examples--usage">Examples / Usage</a></h1>
<blockquote>
<p>All examples share the following definitions:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">lignin</span>::{
  <span class="ident">auto_safety</span>::{<span class="ident">Align</span> <span class="kw">as</span> <span class="kw">_</span>, <span class="ident">AutoSafe</span>, <span class="ident">Deanonymize</span> <span class="kw">as</span> <span class="kw">_</span>}, <span class="comment">// &lt;-- Important!</span>
  <span class="ident">Node</span>, <span class="ident">ThreadBound</span>, <span class="ident">ThreadSafe</span>,
};

<span class="kw">fn</span> <span class="ident">safe</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span>() <span class="op">-</span><span class="op">&gt;</span> <span class="ident">Node</span>::<span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="ident">ThreadSafe</span><span class="op">&gt;</span> { <span class="ident">Node</span>::<span class="ident">Multi</span>(<span class="kw-2">&amp;</span>[]) }
<span class="kw">fn</span> <span class="ident">bound</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span>() <span class="op">-</span><span class="op">&gt;</span> <span class="ident">Node</span>::<span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="ident">ThreadBound</span><span class="op">&gt;</span> { <span class="ident">Node</span>::<span class="ident">Multi</span>(<span class="kw-2">&amp;</span>[]) }
<span class="kw">fn</span> <span class="ident">inferred_safe</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span>() <span class="op">-</span><span class="op">&gt;</span> <span class="kw">impl</span> <span class="ident">AutoSafe</span><span class="op">&lt;</span><span class="ident">Node</span>::<span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="ident">ThreadBound</span><span class="op">&gt;</span><span class="op">&gt;</span> { <span class="ident">safe</span>() }
<span class="kw">fn</span> <span class="ident">inferred_bound</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span>() <span class="op">-</span><span class="op">&gt;</span> <span class="kw">impl</span> <span class="ident">AutoSafe</span><span class="op">&lt;</span><span class="ident">Node</span>::<span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="ident">ThreadBound</span><span class="op">&gt;</span><span class="op">&gt;</span> { <span class="ident">bound</span>() }

<span class="kw">fn</span> <span class="ident">allocate</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="ident">T</span><span class="op">&gt;</span>(<span class="ident">value</span>: <span class="ident">T</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">T</span> {
  <span class="comment">// …</span>
}</pre></div>
<p>I recommend using <a href="https://github.com/fitzgen/bumpalo"><code>bumpalo</code></a> as VDOM allocator since it is fast and versatile, but <code>lignin</code> itself has no preference in this regard.</p>
</blockquote>
<blockquote>
<p>In all examples and the above, except for those in the <a href="#more-lenient-conversions-with-from-and-into">More lenient conversions with <code>From</code> and <code>Into</code></a> section below, <a href="../../lignin/enum.Node.html" title="Node"><code>Node</code></a> can be replaced by any other <a href="../../lignin/trait.Vdom.html" title="Vdom"><code>Vdom</code></a> type.</p>
</blockquote>
<h2 id="basic-forwarding" class="section-header"><a href="#basic-forwarding">Basic Forwarding</a></h2>
<p>To mark the <a href="../../lignin/trait.ThreadSafety.html" title="ThreadSafety"><code>ThreadSafety</code></a> of a function as inferred, return <a href="../../lignin/auto_safety/trait.AutoSafe.html" title="AutoSafe"><code>AutoSafe</code></a> wrapping the <a href="../../lignin/struct.ThreadBound.html" title="ThreadBound"><code>ThreadBound</code></a> version of the VDOM node you want to return.</p>
<p>This works with manually-defined sources…:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">fn</span> <span class="ident">safe_1</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span>() <span class="op">-</span><span class="op">&gt;</span> <span class="kw">impl</span> <span class="ident">AutoSafe</span><span class="op">&lt;</span><span class="ident">Node</span>::<span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="ident">ThreadBound</span><span class="op">&gt;</span><span class="op">&gt;</span> { <span class="ident">safe</span>() }
<span class="kw">fn</span> <span class="ident">bound_1</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span>() <span class="op">-</span><span class="op">&gt;</span> <span class="kw">impl</span> <span class="ident">AutoSafe</span><span class="op">&lt;</span><span class="ident">Node</span>::<span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="ident">ThreadBound</span><span class="op">&gt;</span><span class="op">&gt;</span> { <span class="ident">bound</span>() }</pre></div>
<p>…as well as ones where the original return type is inferred (opaque):</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">fn</span> <span class="ident">safe_2</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span>() <span class="op">-</span><span class="op">&gt;</span> <span class="kw">impl</span> <span class="ident">AutoSafe</span><span class="op">&lt;</span><span class="ident">Node</span>::<span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="ident">ThreadBound</span><span class="op">&gt;</span><span class="op">&gt;</span> { <span class="ident">inferred_safe</span>() }
<span class="kw">fn</span> <span class="ident">bound_2</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span>() <span class="op">-</span><span class="op">&gt;</span> <span class="kw">impl</span> <span class="ident">AutoSafe</span><span class="op">&lt;</span><span class="ident">Node</span>::<span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="ident">ThreadBound</span><span class="op">&gt;</span><span class="op">&gt;</span> { <span class="ident">inferred_bound</span>() }</pre></div>
<h2 id="deanonymization" class="section-header"><a href="#deanonymization">Deanonymization</a></h2>
<p>Rust doesn't allow consumption of the inferred concrete return type of a function directly, so while the following works fine…:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">fn</span> <span class="ident">safe_1</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span>() <span class="op">-</span><span class="op">&gt;</span> <span class="kw">impl</span> <span class="ident">AutoSafe</span><span class="op">&lt;</span><span class="ident">Node</span>::<span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="ident">ThreadBound</span><span class="op">&gt;</span><span class="op">&gt;</span> {
  <span class="ident">Node</span>::<span class="ident">Multi</span>(<span class="ident">allocate</span>([<span class="ident">safe</span>()]))
}

<span class="kw">fn</span> <span class="ident">bound_1</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span>() <span class="op">-</span><span class="op">&gt;</span> <span class="kw">impl</span> <span class="ident">AutoSafe</span><span class="op">&lt;</span><span class="ident">Node</span>::<span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="ident">ThreadBound</span><span class="op">&gt;</span><span class="op">&gt;</span> {
  <span class="ident">Node</span>::<span class="ident">Multi</span>(<span class="ident">allocate</span>([<span class="ident">bound</span>()]))
}</pre></div>
<p>…each of these fails to compile:</p>

<div class='information'><div class='tooltip compile_fail'>ⓘ</div></div><div class="example-wrap"><pre class="rust rust-example-rendered compile_fail">
<span class="kw">fn</span> <span class="ident">safe_2</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span>() <span class="op">-</span><span class="op">&gt;</span> <span class="kw">impl</span> <span class="ident">AutoSafe</span><span class="op">&lt;</span><span class="ident">Node</span>::<span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="ident">ThreadBound</span><span class="op">&gt;</span><span class="op">&gt;</span> {
  <span class="ident">Node</span>::<span class="ident">Ref</span>(<span class="ident">allocate</span>(<span class="ident">inferred_safe</span>()))
  <span class="comment">//                 ^^^^^^^^^^^^^^^ expected enum `Node`, found opaque type</span>
}</pre></div>

<div class='information'><div class='tooltip compile_fail'>ⓘ</div></div><div class="example-wrap"><pre class="rust rust-example-rendered compile_fail">
<span class="kw">fn</span> <span class="ident">bound_2</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span>() <span class="op">-</span><span class="op">&gt;</span> <span class="kw">impl</span> <span class="ident">AutoSafe</span><span class="op">&lt;</span><span class="ident">Node</span>::<span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="ident">ThreadBound</span><span class="op">&gt;</span><span class="op">&gt;</span> {
  <span class="ident">Node</span>::<span class="ident">Ref</span>(<span class="ident">allocate</span>(<span class="ident">inferred_bound</span>()))
  <span class="comment">//                 ^^^^^^^^^^^^^^^^ expected enum `Node`, found opaque type</span>
}</pre></div>
<h3 id="deanonymize" class="section-header"><a href="#deanonymize"><code>.deanonymize()</code></a></h3>
<p>Call <code>.deanonymize()</code> <em>without qualification</em> on an opaquely-typed value to cast it to the underlying named type.</p>
<p>This method resolves either through <a href="../../lignin/auto_safety/trait.AutoSafe.html" title="AutoSafe"><code>AutoSafe</code></a> or <a href="../../lignin/auto_safety/trait.Deanonymize.html" title="Deanonymize"><code>Deanonymize</code></a>, so it's important for both traits to be in scope at the call site!</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">fn</span> <span class="ident">safe_2</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span>() <span class="op">-</span><span class="op">&gt;</span> <span class="kw">impl</span> <span class="ident">AutoSafe</span><span class="op">&lt;</span><span class="ident">Node</span>::<span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="ident">ThreadBound</span><span class="op">&gt;</span><span class="op">&gt;</span> {
  <span class="ident">Node</span>::<span class="ident">Multi</span>(<span class="ident">allocate</span>([<span class="ident">inferred_safe</span>().<span class="ident">deanonymize</span>()]))
}

<span class="kw">fn</span> <span class="ident">bound_2</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span>() <span class="op">-</span><span class="op">&gt;</span> <span class="kw">impl</span> <span class="ident">AutoSafe</span><span class="op">&lt;</span><span class="ident">Node</span>::<span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="ident">ThreadBound</span><span class="op">&gt;</span><span class="op">&gt;</span> {
  <span class="ident">Node</span>::<span class="ident">Multi</span>(<span class="ident">allocate</span>([<span class="ident">inferred_bound</span>().<span class="ident">deanonymize</span>()]))
}</pre></div>
<blockquote>
<p>You also have to do this to annotate the type of local variables…:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">safe_node</span>: <span class="ident">Node</span><span class="op">&lt;</span><span class="kw">_</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">inferred_safe</span>().<span class="ident">deanonymize</span>();
<span class="kw">let</span> <span class="ident">bound_node</span>: <span class="ident">Node</span><span class="op">&lt;</span><span class="kw">_</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">inferred_bound</span>().<span class="ident">deanonymize</span>();</pre></div>
<p>…or to specify a <a href="../../lignin/trait.ThreadSafety.html" title="ThreadSafety"><code>ThreadSafety</code></a> in the return type:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">fn</span> <span class="ident">strictly_safe</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span>() <span class="op">-</span><span class="op">&gt;</span> <span class="ident">Node</span>::<span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="ident">ThreadSafe</span><span class="op">&gt;</span> {
  <span class="ident">inferred_safe</span>().<span class="ident">deanonymize</span>()
}

<span class="kw">fn</span> <span class="ident">strictly_bound</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span>() <span class="op">-</span><span class="op">&gt;</span> <span class="ident">Node</span>::<span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="ident">ThreadBound</span><span class="op">&gt;</span> {
  <span class="ident">inferred_bound</span>().<span class="ident">deanonymize</span>()
}</pre></div>
</blockquote>
<h4 id="identity-cast" class="section-header"><a href="#identity-cast">Identity Cast</a></h4>
<p>Calling <code>.deanonymize()</code> on named types is valid but ultimately useless:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">safe_node</span>: <span class="ident">Node</span><span class="op">&lt;</span><span class="ident">ThreadSafe</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">safe</span>().<span class="ident">deanonymize</span>();
<span class="comment">//                                       ^^^^^^^^^^^</span>
<span class="kw">let</span> <span class="ident">bound_node</span>: <span class="ident">Node</span><span class="op">&lt;</span><span class="ident">ThreadBound</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">bound</span>().<span class="ident">deanonymize</span>();
<span class="comment">//                                          ^^^^^^^^^^^</span>
<span class="comment">//</span>
<span class="comment">// warning:</span>
<span class="comment">//   use of deprecated associated function `lignin::auto_safety::&lt;impl lignin::Node&lt;&#39;a, S&gt;&gt;::deanonymize`:</span>
<span class="comment">//   Call of `.deanonymize()` on named type.</span></pre></div>
<p>Macros can suppress this warning by emitting the method call with <a href="https://doc.rust-lang.org/stable/proc_macro/struct.Span.html#method.mixed_site"><code>Span::mixed_site()</code></a> hygiene.</p>
<!-- TODO: Make sure that's actually the case. -->
<h4 id="no-coercion" class="section-header"><a href="#no-coercion">No Coercion</a></h4>
<p>Calls to <code>.deanonymize()</code> can't be coerced, so each of the following fails to compile:</p>

<div class='information'><div class='tooltip compile_fail'>ⓘ</div></div><div class="example-wrap"><pre class="rust rust-example-rendered compile_fail">
<span class="kw">let</span> <span class="ident">safe_node</span>: <span class="ident">Node</span>::<span class="op">&lt;</span><span class="ident">ThreadSafe</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">inferred_bound</span>().<span class="ident">deanonymize</span>();
<span class="comment">//             ------------------   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</span>
<span class="comment">//             |                    expected struct `ThreadSafe`, found struct `ThreadBound`</span>
<span class="comment">//             expected due to this</span>
<span class="comment">//</span>
<span class="comment">// note: expected enum `Node&lt;&#39;_, ThreadSafe&gt;`</span>
<span class="comment">//          found enum `Node&lt;&#39;_, ThreadBound&gt;`</span></pre></div>

<div class='information'><div class='tooltip compile_fail'>ⓘ</div></div><div class="example-wrap"><pre class="rust rust-example-rendered compile_fail">
<span class="kw">let</span> <span class="ident">bound_node</span>: <span class="ident">Node</span>::<span class="op">&lt;</span><span class="ident">ThreadBound</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">inferred_safe</span>().<span class="ident">deanonymize</span>();
<span class="comment">//              -------------------   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</span>
<span class="comment">//              |                     expected struct `ThreadBound`, found struct `ThreadSafe`</span>
<span class="comment">//              expected due to this</span>
<span class="comment">//</span>
<span class="comment">// note: expected enum `Node&lt;&#39;_, ThreadBound&gt;`</span>
<span class="comment">//          found enum `Node&lt;&#39;_, ThreadSafe&gt;`</span></pre></div>
<h1 id="alignment" class="section-header"><a href="#alignment">Alignment</a></h1>
<p>The <a href="../../lignin/auto_safety/trait.Align.html" title="Align"><code>Align</code></a> trait behaves a lot like <a href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="Into"><code>Into</code></a>, so identity conversions are possible.
However, unlike <a href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="Into"><code>Into</code></a>, it's implemented so that it can change only a type's <a href="../../lignin/trait.ThreadSafety.html" title="ThreadSafety"><code>ThreadSafety</code></a> and isn't warned about by Clippy on identity conversion.</p>
<p>This makes it ideal to combine <a href="../../lignin/enum.Node.html" title="Node"><code>Node</code></a> instances with different or unknown <a href="../../lignin/trait.ThreadSafety.html" title="ThreadSafety"><code>ThreadSafety</code></a> into a single VDOM:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">safe_to_bound</span> <span class="op">=</span> <span class="ident">Node</span>::<span class="ident">Multi</span>(<span class="ident">allocate</span>([
  <span class="ident">safe</span>().<span class="ident">align</span>(),
  <span class="ident">bound</span>(),
]));

<span class="kw">let</span> <span class="ident">safe_to_inferred</span> <span class="op">=</span> <span class="ident">Node</span>::<span class="ident">Multi</span>(<span class="ident">allocate</span>([
  <span class="ident">safe</span>().<span class="ident">align</span>(),
  <span class="ident">inferred_safe</span>().<span class="ident">deanonymize</span>(),
]));

<span class="kw">let</span> <span class="ident">inferred_to_bound</span> <span class="op">=</span> <span class="ident">Node</span>::<span class="ident">Multi</span>(<span class="ident">allocate</span>([
  <span class="ident">bound</span>(),
  <span class="ident">inferred_safe</span>().<span class="ident">deanonymize</span>().<span class="ident">align</span>(),
]));</pre></div>
<h2 id="more-lenient-conversions-with-from-and-into" class="section-header"><a href="#more-lenient-conversions-with-from-and-into">More lenient conversions with <code>From</code> and <code>Into</code></a></h2>
<p><a href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="From"><code>From</code></a> and <a href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="Into"><code>Into</code></a> can both be used to change the <a href="../../lignin/trait.ThreadSafety.html" title="ThreadSafety"><code>ThreadSafety</code></a> of <a href="../../lignin/trait.Vdom.html" title="Vdom"><code>Vdom</code></a> values from <a href="../../lignin/struct.ThreadSafe.html" title="ThreadSafe"><code>ThreadSafe</code></a> to <a href="../../lignin/struct.ThreadBound.html" title="ThreadBound"><code>ThreadBound</code></a>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">safe_to_bound</span>: <span class="ident">Node</span><span class="op">&lt;</span><span class="ident">ThreadBound</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">safe</span>().<span class="ident">into</span>();</pre></div>
<p>Direct <a href="../../lignin/enum.Node.html" title="Node"><code>Node</code></a> conversions, which can also adjust <a href="../../lignin/trait.ThreadSafety.html" title="ThreadSafety"><code>ThreadSafety</code></a>, are additionally available for <strong>references</strong> to
<a href="../../lignin/struct.Element.html" title="Element"><code>Element</code></a> (into <a href="../../lignin/enum.Node.html#variant.Element" title="Node::Element"><code>Node::Element</code></a>), <a href="https://doc.rust-lang.org/stable/core/slice/index.html"><code>[Node]</code></a> (into <a href="../../lignin/enum.Node.html#variant.Multi" title="Node::Multi"><code>Node::Multi</code></a>) and <a href="https://doc.rust-lang.org/std/primitive.str.html" title="str"><code>str</code></a> (into <a href="../../lignin/enum.Node.html#variant.Text" title="Node::Text"><code>Node::Text</code></a>):</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">element_node</span>: <span class="ident">Node</span><span class="op">&lt;</span><span class="ident">ThreadBound</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">allocate</span>(<span class="ident">lignin</span>::<span class="ident">Element</span>::<span class="op">&lt;</span><span class="ident">ThreadSafe</span><span class="op">&gt;</span> {
  <span class="ident">name</span>: <span class="string">&quot;DIV&quot;</span>,
  <span class="ident">attributes</span>: <span class="kw-2">&amp;</span>[],
  <span class="ident">content</span>: <span class="ident">Node</span>::<span class="ident">Multi</span>(<span class="kw-2">&amp;</span>[]),
  <span class="ident">event_bindings</span>: <span class="kw-2">&amp;</span>[],
}).<span class="ident">into</span>();

<span class="kw">let</span> <span class="ident">empty</span>: <span class="kw-2">&amp;</span>[<span class="ident">Node</span><span class="op">&lt;</span><span class="ident">ThreadSafe</span><span class="op">&gt;</span>] <span class="op">=</span> <span class="kw-2">&amp;</span>[];
<span class="kw">let</span> <span class="ident">empty_node</span>: <span class="ident">Node</span><span class="op">&lt;</span><span class="ident">ThreadSafe</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">empty</span>.<span class="ident">into</span>();

<span class="kw">let</span> <span class="ident">text_node</span>: <span class="ident">Node</span><span class="op">&lt;</span><span class="ident">ThreadSafe</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;Hello VDOM!&quot;</span>.<span class="ident">into</span>();</pre></div>
<p><a href="../../lignin/trait.ThreadSafety.html" title="ThreadSafety"><code>ThreadSafety</code></a> alignment is possible at the same time, but this also means relevant annotations or at least nudges (see below) are often necessary.</p>
<!-- TODO: Collect opinions on whether including alignment here is a good idea. -->
<h1 id="threadsafe-preference" class="section-header"><a href="#threadsafe-preference"><code>ThreadSafe</code> Preference</a></h1>
<p>The Rust compiler can usually infer the correct <a href="../../lignin/trait.ThreadSafety.html" title="ThreadSafety"><code>ThreadSafety</code></a> without annotations if valid choices are in any way limited in this regard.</p>
<p>However, this isn't the case for most <a href="../../lignin/trait.Vdom.html" title="Vdom"><code>Vdom</code></a> expressions without inputs with definite <a href="../../lignin/trait.ThreadSafety.html" title="ThreadSafety"><code>ThreadSafety</code></a>…:</p>

<div class='information'><div class='tooltip compile_fail'>ⓘ</div></div><div class="example-wrap"><pre class="rust rust-example-rendered compile_fail">
<span class="kw">let</span> <span class="ident">attempt_1</span> <span class="op">=</span> <span class="ident">Node</span>::<span class="ident">Multi</span>(<span class="kw-2">&amp;</span>[]);
<span class="comment">//  ---------   ^^^^^^^^^^^       // See below.</span></pre></div>
<p>…or if all inputs are thread-safe and <a href="../../lignin/auto_safety/trait.Align.html#method.align"><code>.align()</code></a> is called on each of them:</p>

<div class='information'><div class='tooltip compile_fail'>ⓘ</div></div><div class="example-wrap"><pre class="rust rust-example-rendered compile_fail">
<span class="kw">let</span> <span class="ident">attempt_2</span> <span class="op">=</span> <span class="ident">Node</span>::<span class="ident">Multi</span>(<span class="ident">allocate</span>([<span class="ident">safe</span>().<span class="ident">align</span>(), <span class="ident">inferred_safe</span>().<span class="ident">deanonymize</span>().<span class="ident">align</span>()]));
<span class="comment">//  ---------   ^^^^^^^^^^^ cannot infer type for type parameter `S` declared on the enum `Node`</span>
<span class="comment">//  consider giving `attempt_2` the explicit type `Node&lt;&#39;_, S&gt;`, where the type parameter `S` is specified</span>
<span class="comment">//</span>
<span class="comment">// note: cannot satisfy `_: ThreadSafety`</span>
<span class="comment">// note: required by `Multi`</span></pre></div>
<p>In these cases, you can call <code>.prefer_thread_safe()</code> on the indeterminate expression to nudge the compiler in the right direction.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">safe_1</span> <span class="op">=</span> <span class="ident">Node</span>::<span class="ident">Multi</span>(<span class="kw-2">&amp;</span>[]).<span class="ident">prefer_thread_safe</span>();

<span class="kw">let</span> <span class="ident">safe_2</span> <span class="op">=</span> <span class="ident">Node</span>::<span class="ident">Multi</span>(<span class="ident">allocate</span>([
  <span class="ident">safe</span>().<span class="ident">align</span>(),
  <span class="ident">inferred_safe</span>().<span class="ident">deanonymize</span>().<span class="ident">align</span>(),
])).<span class="ident">prefer_thread_safe</span>();</pre></div>
<blockquote>
<p>This is implemented directly on the individual <a href="../../lignin/trait.Vdom.html" title="Vdom"><code>Vdom</code></a> type variants, so no additional trait imports are necessary to use it.</p>
</blockquote>
<h1 id="limiting-autosafe-exposure" class="section-header"><a href="#limiting-autosafe-exposure">Limiting <code>AutoSafe</code> Exposure</a></h1>
<p>Thread-safety inference is powerful, but also dangerous: A change deep in a library could cause a public function return type to shift, breaking compatibility with downstream crates.
For this reason, and because of its worse ergonomics, <code>-&gt; impl AutoSafe&lt;…&gt;</code> should not be exposed in a crate's public API.</p>
<p>A front-end template language or framework author may still want to avoid requiring explicit threading annotations in most cases.
Even in that case, it's possible to limit this feature to functions not externally visible, by aliasing it with a generated less visible trait:</p>

<div class='information'><div class='tooltip compile_fail'>ⓘ</div></div><div class="example-wrap"><pre class="rust rust-example-rendered compile_fail">
<span class="kw">use</span> <span class="ident">lignin</span>::{
  <span class="ident">auto_safety</span>::<span class="ident">AutoSafe_alias</span>,
  <span class="ident">Node</span>, <span class="ident">ThreadBound</span>,
};

<span class="macro">AutoSafe_alias</span><span class="macro">!</span>(<span class="kw">pub</span>(<span class="kw">crate</span>) <span class="ident">InternalAutoSafe</span>);
<span class="comment">//-------------------------------------------</span>
<span class="comment">//`InternalAutoSafe&lt;Node&lt;&#39;static, ThreadBound&gt;&gt;` declared as private</span>

<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">public</span>() <span class="op">-</span><span class="op">&gt;</span> <span class="kw">impl</span> <span class="ident">InternalAutoSafe</span><span class="op">&lt;</span><span class="ident">Node</span><span class="op">&lt;</span><span class="lifetime">&#39;static</span>, <span class="ident">ThreadBound</span><span class="op">&gt;</span><span class="op">&gt;</span> {
<span class="comment">//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</span>
<span class="comment">//can&#39;t leak private trait</span>
  <span class="ident">Node</span>::<span class="ident">Multi</span>(<span class="kw-2">&amp;</span>[]).<span class="ident">prefer_thread_safe</span>()
}</pre></div>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="comment">// Same imports.</span>

<span class="macro">AutoSafe_alias</span><span class="macro">!</span>(<span class="kw">pub</span>(<span class="kw">crate</span>) <span class="ident">InternalAutoSafe</span>);

<span class="kw">pub</span>(<span class="kw">crate</span>) <span class="kw">fn</span> <span class="ident">less_visible</span>() <span class="op">-</span><span class="op">&gt;</span> <span class="kw">impl</span> <span class="ident">InternalAutoSafe</span><span class="op">&lt;</span><span class="ident">Node</span><span class="op">&lt;</span><span class="lifetime">&#39;static</span>, <span class="ident">ThreadBound</span><span class="op">&gt;</span><span class="op">&gt;</span> {
  <span class="ident">Node</span>::<span class="ident">Multi</span>(<span class="kw-2">&amp;</span>[]).<span class="ident">prefer_thread_safe</span>()
}</pre></div>
<p>As the generated trait is a subtrait of <a href="../../lignin/auto_safety/trait.AutoSafe.html" title="AutoSafe"><code>AutoSafe</code></a>, its instances can be treated the same as that trait's,
as long as <a href="../../lignin/auto_safety/trait.AutoSafe.html" title="AutoSafe"><code>AutoSafe</code></a> and <a href="../../lignin/auto_safety/trait.Deanonymize.html" title="Deanonymize"><code>Deanonymize</code></a> are in scope.</p>
</div><h2 id="macros" class="section-header"><a href="#macros">Macros</a></h2>
<table><tr class="module-item"><td><a class="macro" href="macro.AutoSafe_alias.html" title="lignin::auto_safety::AutoSafe_alias macro">AutoSafe_alias</a></td><td class="docblock-short"><p>Mainly for use by frameworks. Canonically located at <code>auto_safe::AutoSafe_alias</code>.<br />
Creates a custom-visibility alias for <a href="../../lignin/auto_safety/trait.AutoSafe.html"><code>auto_safety::AutoSafe</code></a>.</p>
</td></tr></table><h2 id="traits" class="section-header"><a href="#traits">Traits</a></h2>
<table><tr class="module-item"><td><a class="trait" href="trait.Align.html" title="lignin::auto_safety::Align trait">Align</a></td><td class="docblock-short"><p>Contextually thread-binds an instance, or not. Use only without qualification.</p>
</td></tr><tr class="module-item"><td><a class="trait" href="trait.AutoSafe.html" title="lignin::auto_safety::AutoSafe trait">AutoSafe</a></td><td class="docblock-short"><p>Deanonymize towards the general (<a href="../../lignin/struct.ThreadBound.html" title="ThreadBound"><code>ThreadBound</code></a>) case. Used as <code>-&gt; impl AutoSafe&lt;…&gt;</code>.</p>
</td></tr><tr class="module-item"><td><a class="trait" href="trait.Deanonymize.html" title="lignin::auto_safety::Deanonymize trait">Deanonymize</a></td><td class="docblock-short"><p>Deanonymize towards the special (<a href="../../lignin/struct.ThreadSafe.html" title="ThreadSafe"><code>ThreadSafe</code></a>) case. <strong>This trait must be in scope for correct inference!</strong></p>
</td></tr></table></section><section id="search" class="content hidden"></section><section class="footer"></section><script>window.rootPath = "../../";window.currentCrate = "lignin";</script><script src="../../main.js"></script><script defer src="../../search-index.js"></script></body></html>